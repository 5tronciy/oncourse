buildscript {
	repositories {
		maven {
			url 'http://repo.ish.com.au/content/groups/public'
		}
	}

	dependencies {
		classpath 'org.apache.cayenne:cayenne-tools:3.1B1'
	}
}

allprojects {
	apply plugin: 'java'
	apply plugin: 'maven'

	apply plugin: 'release'
	release {
		scm 'svn'
		failOnSnapshotDependencies true
	}

	repositories {
		maven {
			url 'http://repo.ish.com.au/content/groups/public'
		}
		maven {
			url 'http://repo.ish.com.au/content/groups/ish'
		}
	}

	uploadArchives {
		repositories.mavenDeployer {
			repository(url: 'http://repo.ish.com.au/content/repositories/ish-releases')
			snapshotRepository(url: 'http://repo.ish.com.au/content/repositories/ish-snapshots')
		}
	}

	dependencies {
		testCompile 'junit:junit:4.8.2'
		compile 'log4j:log4j:1.2.17'
	}

	ext.sharedManifest = manifest {
		// attributes('SCM-Revision': release.scmVersion, 'Release-Version': version)
		attributes('SCM-Revision': '123', 'Release-Version': version) //TODO temporary hack because this runs before the release plugin
	}

	test {
		systemProperties 'java.awt.headless': 'true'
		maxHeapSize = '1024m'
		jvmArgs "-XX:MaxPermSize=256m"
		ignoreFailures = true  // ignore test failures so that the test aggregate still works
	}
}
	
configure(subprojects.findAll {it.name == 'server' || it.name == 'client'}) { 

	project.ext {
		appName = getProject().name == 'server' ? "onCourseServer" : "onCourse"
	}

	task jarAll(dependsOn: configurations.default.allArtifacts.buildDependencies, type: Jar) {
		description = 'Creates a shaded/uberjar/fatjar of the application.'
		classifier = 'all'
		version = project.version

		manifest {
			from project.jar.manifest
		}

		from (sourceSets.main.output.classesDir)
		from (sourceSets.main.output.resourcesDir)

		doFirst {
			logger.lifecycle("Creating an fatjar for $project.name ")

			// the following must be executed in doFirst since the configuration
			// has not been initialized at configuration time
			from (configurations.runtime.resolve().collect { it.isDirectory() ? it : zipTree(it) }) {
				exclude 'META-INF/MANIFEST.MF'
				exclude 'META-INF/*.SF'
				exclude 'META-INF/*.DSA'
				exclude 'META-INF/*.RSA'
			}
		}
	}

	project.ext.osxAppFiles = copySpec {
		into("${project.appName}.app") {

			into('Contents') {
				from "${projectDir}/src/packaging/macosx/Info.plist"

				evaluationDependsOn(':' + getProject().name)

				expand([
					maxmemoryServer: project.maxmemoryServer,
					maxpermgenServer: project.maxpermgenServer,
					maxmemoryClient: project.maxmemoryClient,
					sourceCompatibility: project.sourceCompatibility,
					classpath: project.configurations.default.resolve().collect{it.name}.sort(),
					mainJarClasspath : configurations.default.allArtifacts.files.singleFile.name,
					version: version,
					JAVAROOT: '$JAVAROOT' // just a hack to ignore this variable
				])

				from("${projectDir}/src/packaging/macosx/PkgInfo")
			}

			into('Contents/Resources') {
				from("${projectDir}/src/packaging/macosx") {
					include "*.ico"
					include "*.icns"
				}
			}

			into('Contents/MacOS') {
				from("${projectDir}/../common/resources/JavaApplicationStub")
				rename 'JavaApplicationStub', project.appName
				fileMode = 0755
			}

			into('Contents/Resources/Java') {
				from configurations.default
				from configurations.default.allArtifacts.files
				exclude '*-sources.jar'
				exclude '*-javadoc.jar'
			}
		}
	}

	project.ext.osxDmgFiles = copySpec {
		into ("${project.appName}.app") {
			from("${distsDir}/macosx/${project.appName}.app")
		}

		into('.background') {
			from('${projectDir}/src/packaging/macosx')
			include 'background.png'
		}

		into ('.') {
			from("${projectDir}/src/packaging/macosx")
			include 'dmg.DS_Store'
			rename 'dmg.DS_Store', '.DS_Store'
		}
	}

	project.ext.winAppFiles = copySpec {
		into('.') {
			from("${projectDir}/src/packaging/windows/")
			include '*.exe4j.xml'
			expand([
				maxmemoryServer: project.maxmemoryServer,
				maxmemoryServer64: project.maxmemoryServer64,
				maxpermgenServer: project.maxpermgenServer,
				maxmemoryClient: project.maxmemoryClient,
				sourceCompatibility: sourceCompatibility,
				version: version,
				jarAll: "${libsDir}/${project.name}-${version}-all.jar"
			])
		}

		into('.') {
			from("${projectDir}/src/packaging/windows/")
			include '*.ico'
		}
	}

	task bundle_osx(dependsOn: jar, type: Copy) {
		description "Create the OSX application executable."
		doFirst {
			logger.lifecycle("Creating the OSX application executable for $project.name")
		}

		inputs.files osxAppFiles.getSource()
		outputs.files "${distsDir}/macosx/*.app"

		with osxAppFiles
		into file("${distsDir}/macosx")
		doLast {
			try {
				exec {
					executable = "codesign"
					args = [	
						"-s", "onCourse",
						"--keychain", "jenkins",
						"-f", "${distsDir}/macosx/${project.appName}.app"]
				}
				logger.lifecycle("${project.appName}.app successfully codesigned")
			} catch (Exception e) {
				logger.lifecycle("${project.appName}.app was not codesigned")
			}
		}
	}

	task bundle_win(dependsOn: jarAll, type: Copy) {
		description "Create the Windows application executable."
		doFirst {
			logger.lifecycle("Creating the Windows application executable for $project.name")
		}

		inputs.files winAppFiles.getSource()
		outputs.files "${distsDir}/windows/*.exe"

		with winAppFiles
		into file("${buildDir}/tmp/exe4j")

		doLast {
			ant.taskdef(name: 'exe4j', classname: 'com.exe4j.Exe4JTask', classpath: "${projectDir}/../lib/exe4j/bin/ant.jar")
			
			def exe4jCollection = file("${distsDir}/tmp/exe4j").listFiles().findAll {it.name.endsWith('.exe4j.xml')}
			for (File f : exe4jCollection) {
				logger.lifecycle("Executing exe4j with " + f.getAbsolutePath())
				ant.exe4j(projectfile: f, release: version, requirelicense: 'true', destination: "${distsDir}/windows/")
			}
			logger.info("Deleting windows work files");
			delete "${buildDir}/tmp/exe4j"
		}
	}

	task bundle(dependsOn: [bundle_win, bundle_osx]) {
		description "Create all application executables."
	}

	task installer_osx(dependsOn: bundle_osx, type: Copy) {
		description "Create the OSX installer (which is just a dmg file)."
		doFirst {
			logger.lifecycle("Creating the OSX installer (which is just a dmg file) for $project.name")
		}

		def dmgSource = "${distsDir}/macosx/${project.appName}"
		inputs.files osxDmgFiles.getSource()
		outputs.files "${dmgSource}.dmg"

		with osxDmgFiles
		into file(dmgSource)

		doLast {
			if (file("${dmgSource}.dmg").exists()) delete "${dmgSource}.dmg"

			exec {
				executable = "hdiutil"
				args = ["create", 
				"-srcfolder", dmgSource,
				"-volname", "${project.appName}",
				"${dmgSource}.dmg"]
			}
			logger.info("Deleting dmg work files");
			delete dmgSource
		}
	}

	task installer_win(dependsOn: bundle_win, type: Copy) {
		description "Create the Windows installer."
		doFirst {
			logger.lifecycle("Creating the Windows installer for $project.name")
		}

		from "${projectDir}/src/packaging/windows"
		include '*.nsi' 
		include '*.bmp'
		into "${distsDir}/windows"
		
		doLast {
			def nsisFiles = fileTree("${distsDir}/windows/").include('**/*.nsi')

			nsisFiles.each {File file ->
				logger.lifecycle("Executing makensis for "+file.getAbsolutePath())
    			exec {
					executable = "makensis"
					args = [file.getAbsolutePath()]
				}
			}
		}
	}

	task installer(dependsOn: [installer_win, installer_osx, ':client:installer_webstart', ':server:installer_freebsd', ':server:installer_unix']) {
		description "Create all application installers."
	}
}

/*

	Additional functionality which might later be turned into plugins

*/

task aggregateTestReports(type: TestReportAggregator) {
    testReportDir = file("${reportsDir}/tests")
    testResultsDir = file("${buildDir}/test-results")
    projects = subprojects
}

class TestReportAggregator extends Copy {
    def projects
    File testResultsDir
    @OutputDirectory
    File testReportDir
    def TestReportAggregator() {
        dependsOn { testTasks }
        from { inputTestResultDirs }
        into { testResultsDir }
    }
    @TaskAction
    def aggregate() {
        def report = new org.gradle.api.internal.tasks.testing.junit.report.DefaultTestReport(testReportDir: testReportDir, testResultsDir: testResultsDir)
        report.generateReport()
    }
    def getTestTasks() {
        projects.collect { it.tasks.withType(Test) }.flatten()
    }
    def getInputTestResultDirs() {
        testTasks*.testResultsDir
    }
}