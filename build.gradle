buildscript {
	repositories {
		maven {
			url 'http://repo.ish.com.au/content/groups/public'
		}

		ivy {
            url "http://gradle-macappbundle.googlecode.com"
            artifactPattern 'http://gradle-macappbundle.googlecode.com/files/[module]-[revision].[ext]'
        }
	}

	dependencies {
		classpath 'org.apache.cayenne:cayenne-tools:3.1B1'
		classpath 'org.apache.maven.wagon:wagon-http:2.2'
		classpath 'edu.sc.seis:gradle-macappbundle:1.0.7'
	}
}

allprojects {
	apply plugin: 'java'
	apply plugin: 'maven'

	apply plugin: 'release'
	release {
		scm = 'svn'
		failOnSnapshotDependencies = true
	}

	configurations {
		deployerJars {
			description = 'Jars needed for doing deployment to JBoss Nexus repo'
		}
	}

	repositories {
		maven {
			url 'http://repo.ish.com.au/content/groups/public'
		}
		maven {
			url 'http://repo.ish.com.au/content/groups/ish'
		}
	}

	dependencies {
		testCompile 'junit:junit:4.8.2'
		compile 'log4j:log4j:1.2.17'
		deployerJars 'org.apache.maven.wagon:wagon-http:1.0-beta-2'
	}

	uploadArchives.dependsOn install
	group = 'ish.oncourse.angel'
	uploadArchives {
		repositories.mavenDeployer {
			name = 'ishRepo'
			configuration = configurations.deployerJars
			repository(id:'internal-releases', url: 'http://repo.ish.com.au/content/repositories/ish-releases') {
				authentication(userName: nexusUsername, password: nexusPassword)
			}
			snapshotRepository(id:'internal-snapshots', url: 'http://repo.ish.com.au/content/repositories/ish-snapshots') {
				authentication(userName: nexusUsername, password: nexusPassword)
			}
		}
	}

	ext.sharedManifest = manifest {
		attributes 'SCM-Revision': project.release.scmVersion,
			'Release-Version': version,
			'Built-Date': new Date(),
			'Built-JDK': System.getProperty('java.version'),
			'Built-Gradle': gradle.gradleVersion
	}

	test {
		systemProperties 'java.awt.headless': 'true'
		maxHeapSize = '1024m'
		jvmArgs "-XX:MaxPermSize=256m"
		ignoreFailures = true  // ignore test failures so that the test aggregate still works
	}
}
	
configure(subprojects.findAll {it.name == 'server' || it.name == 'client'}) { 

	project.ext {
		appName = getProject().name == 'server' ? "onCourseServer" : "onCourse"
	}

	task jarAll(dependsOn: configurations.default.allArtifacts.buildDependencies, type: Jar) {
		description = 'Creates a shaded/uberjar/fatjar of the application.'
		classifier = 'all'
		version = project.version

		manifest {
			from project.jar.manifest
		}

		from (sourceSets.main.output.classesDir)
		from (sourceSets.main.output.resourcesDir)

		doFirst {
			logger.lifecycle("Creating an fatjar for $project.name ")

			// the following must be executed in doFirst since the configuration
			// has not been initialized at configuration time
			from (configurations.runtime.resolve().collect { it.isDirectory() ? it : zipTree(it) }) {
				exclude 'META-INF/MANIFEST.MF'
				exclude 'META-INF/*.SF'
				exclude 'META-INF/*.DSA'
				exclude 'META-INF/*.RSA'
			}
		}
	}

	task bundle(dependsOn: tasks.findAll { task -> task.name.startsWith('bundle_') }) {
		description "Create all application executables."
	}

	bundle.dependsOn {
		project.tasks.findAll { it.name.startsWith('bundle_') }
	}

	task installer(){
		description "Create all application installers."
	}
	installer.dependsOn {
		project.tasks.findAll { it.name.startsWith('installer_') }
	}
}

/*

	Additional functionality which might later be turned into plugins

*/

task aggregateTestReports(type: TestReportAggregator) {
    testReportDir = file("${reporting.baseDir}/tests")
    testResultsDir = file("${buildDir}/test-results")
    projects = subprojects
}

class TestReportAggregator extends Copy {
    def projects
    File testResultsDir
    @OutputDirectory
    File testReportDir
    def TestReportAggregator() {
        dependsOn { testTasks }
        from { inputTestResultDirs }
        into { testResultsDir }
    }
    @TaskAction
    def aggregate() {
        def report = new org.gradle.api.internal.tasks.testing.junit.report.DefaultTestReport(testReportDir: testReportDir, testResultsDir: testResultsDir)
        report.generateReport()
    }
    def getTestTasks() {
        projects.collect { it.tasks.withType(Test) }.flatten()
    }
    def getInputTestResultDirs() {
        testTasks*.testResultsDir
    }
}
